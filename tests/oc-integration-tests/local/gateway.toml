# This config file will start a reva service that:
# - serves as a gateway for all CS3 requests
# - looks up the storageprovider using a storageregistry
# - looks up the authprovider using an authregistry
# - serves the gateway on grpc port 19000
# - serves http datagateway on port 19001
#   - /data - datagateway: file up and download

[shared]
jwt_secret = "Pive-Fumkiu4"
gatewaysvc = "localhost:19000"

[log]
#level = "warn"
#mode = "json"

[grpc]
address = "0.0.0.0:19000"

[grpc.services.gateway]
# registries
authregistrysvc = "localhost:19000"
storageregistrysvc = "localhost:19000"
# user metadata
preferencessvc = "localhost:18000"
userprovidersvc = "localhost:18000"
groupprovidersvc = "localhost:18000"
# an approvider lives on "localhost:18000" as well, see users.toml
# sharing
usershareprovidersvc = "localhost:17000"
publicshareprovidersvc = "localhost:17000"
# ocm
ocmcoresvc = "localhost:14000"
ocmshareprovidersvc = "localhost:14000"
ocminvitemanagersvc = "localhost:14000"
ocmproviderauthorizersvc = "localhost:14000"
# other
commit_share_to_storage_grant = true
commit_share_to_storage_ref = true
share_folder = "Shares"
datagateway = "http://localhost:19001/data"
transfer_shared_secret = "replace-me-with-a-transfer-secret" # for direct uploads
transfer_expires = 6 # give it a moment
#disable_home_creation_on_login = true
link_grants_file = "/var/tmp/reva/link_grants_file.json"


[grpc.services.authregistry]
driver = "static"

[grpc.services.authregistry.drivers.static.rules]
publicshares = "localhost:17000" # started with the shares.toml
basic = "localhost:18000" # started with the users.toml
bearer = "localhost:20099" # started with the frontend.toml
machine = "localhost:21000" # started with the machine-auth.toml

[grpc.services.storageregistry]
driver = "spaces"

[grpc.services.storageregistry.drivers.spaces]
home_provider = "/users"

[grpc.services.storageregistry.drivers.spaces.rules]
## this is the bare function of the registry: map path to spaceid
#"/users/einstein" = {"spaceid" = "f7fbf8c8-139b-4376-b307-cf0a8c2d0d9c"}
#"/users/marie" = {"spaceid" = "..."}
## obviously, we do not want to define a rule for every user and space, which is why wa can define naming rules:
#"/users" = {"address" = "localhost:11000", "spacetype" = "personal", "path_template" = "/users/{.Owner.Username}" }
## this will ask all known providers for a personal spaces and map their name as the path segment
## in memory this would become
#"/users/einstein" = {"spaceid" = "f7fbf8c8-139b-4376-b307-cf0a8c2d0d9c"}
#"/users/marie" = {"spaceid" = "..."}

## furthermore there are well known aliases, eg:
#"/home" = {"address" = "localhost:11000", "spacetype" = "personal", "spaceowner" = "self"}
#"/home/Shares" = {"spacetype" = "share", "filter" = "access"}
#"/shares" = {"spacetype" = "share", "filter" = "access"}
## If all clients understood spaces thero would only be one rule
## There is only a single /spaces/{spaceid} folder in the cs3 namespace
#"/spaces" = {"filter" = "access", "mapping" = "{.ID}" } 

## further thoughts
## to make clear /users is a list of spaces:
#"/users/*" = {"spacetype" = "personal", "mapping" ="{.Owner.Username}" }
## regexes
#"/users/[i-k]" = {"spacetype" = "personal", "mapping" ="{{.Space.Name}}" }
#"/users/[l-z]" = {"spacetype" = "personal", "mapping" ="{{.Space.Name}}" }
## regexes and wildcard hale the problem that they make it harder to tell the gateway what part of the path to truncate
## this would require an explicit mount point property in the rule
#"/users/*" = {"spacetype" = "personal", "mapping" ="{{.Space.Name}}", "mount_point"="/users" }
#"/users/[i-k]" = {"spacetype" = "personal", "mapping" ="{{.Space.Name}}", "mount_point"="/users" }
#"/users/[l-z]" = {"spacetype" = "personal", "mapping" ="{{.Space.Name}}", "path_template" ="/users/{.Owner.Username}"}

"/users" = {"address" = "localhost:11000", "space_type" = "personal", "path_template" = "/users/{{.Space.Owner.Id.OpaqueId}}", "description" = "personal spaces"}
"/users/{{.CurrentUser.Id.OpaqueId}}/Shares" = {"address" = "localhost:14000", "space_type" = "share", "path_template" = "/users/{{.CurrentUser.Id.OpaqueId}}/Shares/{{.Space.Name}}", "description" = "shares"}

# the /virtual namespace is only accessible via the frontend-global service
"/virtual/[a-k]" = {"address" = "localhost:11100", "path_template" = "/virtual/{{.Space.Owner.Id.OpaqueId}}"}
"/virtual/[l-z]" = {"address" = "localhost:11110", "path_template" = "/virtual/{{.Space.Owner.Id.OpaqueId}}"}

"/public" = {"address" = "localhost:13000",  "space_type" = "public", "path_template" = "/public/{{.Space.Name}}", "description" = "public links"}

[http]
address = "0.0.0.0:19001"

[http.services.datagateway]
transfer_shared_secret = "replace-me-with-a-transfer-secret"
